# Regras Gerais do Projeto DOM

## 1. Padrão de UI: Material UI
- Todos os componentes visuais devem ser implementados exclusivamente com Material UI (MUI).
- É proibido o uso de componentes de outras bibliotecas de UI (ex: Ant Design, Bootstrap, Chakra, PrimeReact, etc) ou componentes customizados de UI, exceto se baseados no MUI.
- PRs que incluam componentes visuais não-MUI devem ser rejeitados.
- Consulte sempre a documentação oficial do MUI para customizações e dúvidas.

## 2. Formulários
- Cada formulário deve ter seu próprio hook customizado (ex: useLoginForm).
- Toda lógica de submit, validação e integração com API deve estar centralizada no hook.
- Campos reutilizáveis DEVEM receber a prop `control` do hook customizado.
- É proibido misturar <FormProvider> e prop `control` no mesmo formulário.
- Mensagens de erro e sucesso devem ser padronizadas, amigáveis e internacionalizáveis, sempre usando o dicionário central.
- Testes automatizados devem cobrir o fluxo dos formulários.
- Todos os campos e formulários devem ser acessíveis (labels, aria, etc) e responsivos.

## 2.1. Acessibilidade em Formulários (Obrigatório)
- Todo campo de formulário (input, select, datepicker, number, etc) deve possuir um `id` único e um `label` visível associado.
- Se não for possível exibir um label visível, é obrigatório o uso de `aria-label` ou `aria-labelledby` com texto descritivo.
- Wrappers e componentes customizados (ex: FormInput, FormDatePicker, FormNumberInput) DEVEM repassar corretamente as props `id`, `label` e `aria-label` para o componente MUI interno.
- O `label` deve ser passado para o componente MUI (`TextField`, `Select`, etc) e vinculado ao campo via `id`.
- Nunca use `<option>` dentro de `<TextField select>`, apenas `<MenuItem>`.
- PRs que não seguirem essas regras de acessibilidade devem ser rejeitados.
- Consulte sempre a documentação oficial do Material UI e as recomendações do axe/wcag para dúvidas de acessibilidade.

## 3. Navegação
- Sempre use o componente Link do Next.js (next/link) para navegação.
- É proibido usar react-router-dom.

## 4. Nomenclatura e Organização
- Páginas: minúsculo e hífen (kebab-case).
- Componentes: PascalCase.
- Nunca use arquivos com sufixos de backup ou rascunho (_old, -old, Copia, etc).
- Estrutura de diretórios clara, com divisão por responsabilidade e tamanho ideal de arquivos (código: 200-400 linhas, teste: 100-200, config: 50-100).

## 5. Banco de Dados
- Use sempre Prisma + Postgres.
- Não altere migrations manualmente.
- Seeds devem ser pequenos, idempotentes e tipados.

## 6. Tipagem
- É proibido o uso de any (exceto com justificativa documentada).
- Use tipos específicos, unknown, type guards, zod/yup para validação runtime.
- Configure o ESLint para rejeitar any e use TypeScript strict mode.

## 7. Estilo e Tema
- Sempre use o tema do Material UI (theme.palette, theme.spacing, etc).
- Não use estilos inline, exceto em casos justificados e documentados.
- Padronize cores, espaçamentos e fontes conforme o tema.

## 8. Tooltips e Internacionalização
- Tooltips devem ser retirados do dicionário central (src/i18n/tooltips.ts), nunca hardcoded.
- Sempre envolver o filho do <Tooltip> em um elemento que aceite ref (ex: <span>).
- Todos os textos do dicionário devem estar traduzidos para os idiomas suportados.

## 9. Code Review e PR
- PRs devem seguir todas as regras acima.
- Checklist obrigatório de PR.
- Rejeite PRs que violem qualquer regra.
- Explique comandos de terminal sugeridos, sempre em PowerShell.

## 10. ESLint
- Bloqueie imports de bibliotecas de UI que não sejam Material UI.
- Rejeite uso de any e estilos inline.

# Regras de Tipagem
- É proibido o uso de 'any' em todo o projeto. Utilize tipos específicos ou 'unknown'.
- Exceções só são permitidas em casos extremamente justificados e documentados no próprio código, explicando o motivo da escolha.
- Exemplo de justificativa:
  // Justificativa: integração com biblioteca externa sem tipos disponíveis
  const valor: any = obterValorExterno();

# Mecanismos de Controle de Tipagem
- Configure o ESLint para rejeitar o uso de 'any' com a regra '@typescript-eslint/no-explicit-any': 'error'
- Use o TypeScript strict mode em tsconfig.json
- Implemente tipos genéricos para funções e componentes reutilizáveis
- Crie interfaces e types para todas as estruturas de dados
- Utilize type guards para validação de tipos em runtime
- Documente todos os tipos em arquivos .d.ts separados
- Use zod ou yup para validação de tipos em runtime
- Implemente testes de tipo com tsc --noEmit

# Processo de Code Review
- Rejeite PRs que contenham 'any' sem justificativa documentada
- Exija testes de tipo para todas as alterações
- Verifique a cobertura de tipos em CI/CD
- Mantenha um registro de exceções aprovadas 

# Regras de Desenvolvimento

## Tamanho e Organização de Arquivos

### Tamanho Ideal de Arquivos
- Arquivos de código: 200-400 linhas
- Arquivos de teste: 100-200 linhas
- Arquivos de configuração: 50-100 linhas

### Divisão de Arquivos
Arquivos que excedam o tamanho ideal devem ser divididos seguindo estas regras:

1. **Por Responsabilidade:**
```
src/components/forms/empregado/
  ├── EmpregadoForm.tsx        // Componente principal
  ├── EmpregadoFormFields.tsx  // Campos do formulário
  ├── EmpregadoFormTypes.ts    // Tipos e interfaces
  └── EmpregadoFormUtils.ts    // Funções utilitárias
```

2. **Por Funcionalidade:**
```
src/hooks/esocial/
  ├── useEsocialEventForm.ts     // Hook principal
  ├── useEsocialEventTypes.ts    // Tipos
  ├── useEsocialEventUtils.ts    // Funções utilitárias
  └── useEsocialEventSchema.ts   // Schemas de validação
```

3. **Por Contexto:**
```
src/tests/components/form/
  ├── FormInput.test.tsx
  ├── FormInput.snapshot.test.tsx
  └── FormInput.integration.test.tsx
```

### Regras de Divisão

1. **Coesão:**
   - Mantenha funções relacionadas juntas
   - Separe por responsabilidade
   - Evite acoplamento desnecessário

2. **Nomenclatura:**
   - Use nomes descritivos
   - Mantenha um padrão consistente
   - Agrupe por funcionalidade

3. **Estrutura:**
   - Mantenha uma estrutura de diretórios clara
   - Use index.ts para exportações
   - Documente a estrutura

### Benefícios

1. **Manutenibilidade:**
   - Cada arquivo tem uma responsabilidade única
   - Mais fácil de encontrar e corrigir bugs
   - Mais fácil de adicionar novas funcionalidades

2. **Testabilidade:**
   - Testes mais focados e menores
   - Mais fácil de mockar dependências
   - Melhor cobertura de código

3. **Reusabilidade:**
   - Funções utilitárias podem ser reutilizadas
   - Tipos podem ser compartilhados
   - Schemas podem ser reutilizados

4. **Performance:**
   - Arquivos menores são mais rápidos de carregar
   - Melhor tree-shaking
   - Melhor cache do navegador

### Exemplos de Divisão

1. **Componentes:**
```typescript
// Antes: EmpregadoForm.tsx (500+ linhas)
// Depois:
src/components/forms/empregado/
  ├── EmpregadoForm.tsx
  ├── EmpregadoFormFields.tsx
  ├── EmpregadoFormTypes.ts
  └── EmpregadoFormUtils.ts
```

2. **Hooks:**
```typescript
// Antes: useEsocialEventForm.ts (400+ linhas)
// Depois:
src/hooks/esocial/
  ├── useEsocialEventForm.ts
  ├── useEsocialEventTypes.ts
  ├── useEsocialEventUtils.ts
  └── useEsocialEventSchema.ts
```

3. **Testes:**
```typescript
// Antes: FormInput.test.tsx (300+ linhas)
// Depois:
src/tests/components/form/
  ├── FormInput.test.tsx
  ├── FormInput.snapshot.test.tsx
  └── FormInput.integration.test.tsx
```

### Processo de Code Review

1. **Verificação de Tamanho:**
   - Rejeite PRs com arquivos que excedam o tamanho ideal
   - Sugira divisão quando necessário
   - Verifique a coesão dos arquivos divididos

2. **Verificação de Estrutura:**
   - Confirme se a divisão segue as regras
   - Verifique se os nomes são descritivos
   - Confirme se a documentação está atualizada

3. **Verificação de Qualidade:**
   - Confirme se os testes foram atualizados
   - Verifique se as dependências foram corretamente importadas
   - Confirme se não há duplicação de código

### Exceções

1. **Arquivos de Configuração:**
   - Podem exceder o limite se necessário
   - Devem ser bem documentados
   - Devem ser divididos por contexto

2. **Arquivos de Migração:**
   - Podem exceder o limite se necessário
   - Devem ser bem documentados
   - Devem ser divididos por versão

3. **Arquivos de Documentação:**
   - Podem exceder o limite se necessário
   - Devem ser bem estruturados
   - Devem ser divididos por tópico 

# Regra de Duplicidade de Arquivos
- É proibido manter arquivos duplicados no projeto, incluindo:
  - Arquivos com nomes iguais em diretórios diferentes sem justificativa técnica clara.
  - Arquivos com sufixos como _old, -old, Copia, -copia, -copy, backup, etc.
  - Componentes, hooks ou utilitários que tenham a mesma responsabilidade em múltiplos lugares.
- Todo código duplicado deve ser centralizado e referenciado por import único.
- Pull Requests com duplicidade serão rejeitados.
- Justificativas para exceções devem ser documentadas no próprio código e aprovadas pelo time. 

# Regras de Tooltips
- O texto dos tooltips deve ser sempre retirado do dicionário central de mensagens (ex: src/i18n/tooltips.ts), nunca hardcoded no componente.
- O dicionário deve ser internacionalizável e versionado no repositório. 

# Boas Práticas para Uso do Prisma, Seeds e Validação de Modelos
- Sempre edite o arquivo `prisma/schema.prisma` para criar, alterar ou remover campos/tabelas.
- Após qualquer alteração, execute:
  - `npx prisma migrate dev` — para aplicar as migrations no banco de dados.
  - `npx prisma generate` — para atualizar os tipos do Prisma Client.
- Antes de criar ou alterar seeds, consulte o modelo no `schema.prisma` e utilize o autocomplete do Prisma Client no seu editor.
- No seed, **NUNCA** inclua campos que não existem no modelo Prisma.
- Utilize apenas os campos obrigatórios e opcionais definidos no modelo.
- Seeds devem ser pequenos, testáveis e idempotentes (podem ser rodados mais de uma vez sem corromper dados).
- Utilize o autocomplete do Prisma Client para garantir que está usando apenas campos válidos.
- Em caso de erro ao rodar o seed, leia atentamente a mensagem do Prisma — geralmente ela indica o campo inválido ou ausente.
- Utilize o Prisma Studio (`npx prisma studio`) para inspecionar os dados e modelos de forma visual.
- Adicione logs no seed para facilitar a identificação de onde ocorreu o erro.
- Seeds e scripts de banco devem ser escritos em TypeScript, aproveitando a tipagem do Prisma.
- Evite hardcode de campos dinâmicos; utilize tipos e interfaces.
- Documente erros comuns e soluções neste arquivo para consulta futura do time. 

# Regra obrigatória de Grid (Material UI v2)
- Todo uso do componente Grid do Material UI deve seguir o padrão do Grid v2:
  - Sempre utilize a prop `columns={12}` no container.
  - Substitua as props `xs`, `sm`, `md`, `lg`, `xl` por `gridColumn` no formato objeto:
    <Grid gridColumn={{ xs: 'span 12', sm: 'span 6', md: 'span 4' }}>...</Grid>
  - Exemplo de migração:
    Antes:
    <Grid xs={12} sm={6} md={4}>...</Grid>
    Depois:
    <Grid gridColumn={{ xs: 'span 12', sm: 'span 6', md: 'span 4' }}>...</Grid>
  - O container deve ser:
    <Grid container columns={12} spacing={2}>...</Grid>
  - Nunca misture o padrão antigo (`xs`, `sm`, etc.) com o novo (`gridColumn`).
  - Consulte a documentação oficial do MUI Grid v2 para detalhes. 

## Regras obrigatórias de UI e Integração

### Grid Material UI v2
- É obrigatório utilizar apenas o padrão Grid v2 do Material UI.
- É proibido o uso das props antigas (`item`, `xs`, `sm`, etc.).
- Sempre utilize `<Grid container columns={12}>` para containers e `gridColumn={{ xs: 'span 12', ... }}` para itens.
- Consulte a documentação oficial do MUI Grid v2 para detalhes.

### Selects (Campos de Seleção)
- Todo campo select deve ser inicializado com um valor válido (ex: `''` para "Todos" ou o primeiro valor da lista).
- Nunca inicialize selects com `undefined`.
- Sempre inclua uma opção "Todos" ou equivalente, se aplicável.
- Garanta que o valor inicial do formulário nunca seja `undefined` para selects.

### Uso correto do Tooltip do MUI
- Sempre envolva o componente filho do `<Tooltip>` em um elemento que aceite refs e props, como `<span>`, quando necessário.
- Nunca envolva diretamente componentes que não aceitam refs (ex: `<DatePicker>`, `<ButtonGroup>`, etc.) com `<Tooltip>`.
- O texto do tooltip deve ser retirado do dicionário central de mensagens.

### Autenticação e tratamento de erros de API
- Toda chamada de API protegida deve garantir que o token de autenticação está presente e válido.
- Trate erros 401/403 exibindo mensagens amigáveis e orientando o usuário a fazer login novamente.
- Nunca exponha detalhes sensíveis de erro para o usuário final.

### Observação
Essas regras são obrigatórias para todo o time e para a IA. Pull Requests que não seguirem essas diretrizes devem ser rejeitados até a adequação. 

### Tooltips e Internacionalização

- Todo campo de formulário ou componente que exiba tooltip deve obrigatoriamente utilizar o dicionário central de tooltips (`src/i18n/tooltips.ts`).
- É proibido usar textos hardcoded em `title`, `tooltip` ou diretamente em `<Tooltip>`.
- Sempre que criar um novo campo ou formulário, adicione a chave correspondente no dicionário central de tooltips e utilize a prop `tooltip={tooltips.campo.pt}`.
- Antes de aprovar um PR, revise se todos os tooltips estão centralizados e internacionalizados. Busque por `title=", `tooltip=", ou textos hardcoded.
- Todos os textos do dicionário central de tooltips devem estar traduzidos para os idiomas suportados pelo sistema. 

### Tooltips em Componentes Reutilizáveis

- Todo componente reutilizável que aceite prop de tooltip (ex: `tooltip` em `BadgeIcon`, `IconButton`, etc.) deve aceitar **apenas textos vindos do dicionário central de tooltips** (`src/i18n/tooltips.ts`).
- É proibido passar texto hardcoded diretamente para tooltips nesses componentes.
- Sempre documente na interface/prop do componente que o valor deve vir do dicionário central.
- Pull Requests que não seguirem essa regra devem ser rejeitados. 

# Padrão obrigatório para ações em tabelas
- Todo novo módulo que utilize ações em tabela deve obrigatoriamente usar o componente TableActions seguindo o padrão de array de ações, com ícone, tooltip do dicionário central (src/i18n/tooltips.ts), função de clique, ariaLabel e disabled.
- É proibido usar textos hardcoded em tooltips ou passar ações fora desse padrão.
- Todos os tooltips devem ser internacionalizados e centralizados.
- Todos os botões devem ser acessíveis (aria-label, foco, etc.).
- PRs que não seguirem esse padrão devem ser rejeitados. 

## Regra obrigatória de cabeçalho de documentação em arquivos

Todo arquivo de código-fonte (.ts, .tsx, .js, .jsx, .mjs, .css, .scss, .html, .md) deve conter, no topo, um cabeçalho de documentação com as seguintes informações:

- Nome do arquivo com extensão
- Caminho relativo ao projeto
- Data de criação
- Data da última atualização
- Breve descrição do propósito/função do arquivo

**Exemplo de cabeçalho:**

```typescript
/**
 * Arquivo: EmpregadorForm.tsx
 * Caminho: src/components/forms/empregador/EmpregadorForm.tsx
 * Criado em: 2024-06-07
 * Última atualização: 2024-06-07
 * Descrição: Componente React de formulário adaptativo para cadastro de empregador, com modo simplificado e complementar.
 */
```

Essa regra é obrigatória para todo o time e para a IA. Pull Requests sem o cabeçalho padronizado serão rejeitados. 

# Regras obrigatórias de Material UI: estilos e selects

- É obrigatório utilizar a prop `sx` do Material UI para todos os estilos customizados em componentes do MUI.
- É proibido o uso de `style={{ ... }}` (inline style) em componentes React, exceto em casos extremamente justificados e documentados no próprio código.
- Todo campo `select` do Material UI deve utilizar componentes `<MenuItem>` como filhos.
- É proibido usar `<option>` dentro de `<TextField select>`.
- O campo `label` do `TextField` já garante acessibilidade para selects do MUI. É redundante adicionar `aria-label` em selects do Material UI quando o `label` já está presente. 

# Regras obrigatórias de tipagem para componentes de formulário

- Todo componente de formulário reutilizável (ex: FormInput, PasswordInput, Checkbox) deve ser implementado como componente genérico, aceitando o tipo do formulário via parâmetro genérico (ex: <T extends FieldValues>).
- O parâmetro control deve ser tipado como Control<T> para garantir compatibilidade com o hook do formulário e evitar warnings de tipagem.
- Sempre passe explicitamente o tipo do formulário ao usar esses componentes em páginas ou outros componentes (ex: <PasswordInput<LoginForm> ... />). 

# Padrão obrigatório de UI: apenas Material UI
Todos os componentes visuais do projeto devem ser implementados exclusivamente com Material UI (MUI). É proibido o uso de componentes de outras bibliotecas de UI (ex: Ant Design, Bootstrap, Chakra, PrimeReact, etc) ou componentes customizados de UI, exceto se baseados no MUI.
- PRs que incluam componentes visuais não-MUI devem ser rejeitados.
- Sempre consulte a documentação oficial do MUI para customizações e dúvidas.
- Em caso de necessidade de componente customizado, este deve ser construído a partir dos componentes do MUI. 

## 11. Cabeçalho de Documentação Obrigatório
- Todo arquivo de código-fonte (.ts, .tsx, .js, .jsx, .mjs, .css, .scss, .html, .md) deve conter, no topo, um cabeçalho de documentação com as seguintes informações:
  - Nome do arquivo com extensão
  - Caminho relativo ao projeto
  - Data de criação
  - Data da última atualização
  - Breve descrição do propósito/função do arquivo
- Exemplo de cabeçalho:
```typescript
/**
 * Arquivo: EmpregadorForm.tsx
 * Caminho: src/components/forms/empregador/EmpregadorForm.tsx
 * Criado em: 2024-06-07
 * Última atualização: 2024-06-07
 * Descrição: Componente React de formulário adaptativo para cadastro de empregador, com modo simplificado e complementar.
 */
```
- PRs sem o cabeçalho padronizado devem ser rejeitados. 

## 12. Imports Internos
- Todos os imports de arquivos dentro de src/ DEVEM usar o alias '@/'. Caminhos relativos como '../' ou './' são proibidos para arquivos dentro de src/.
- O tsconfig.json já está configurado com baseUrl e paths para suportar esse padrão.

## 13. Gerenciador de Pacotes
- O projeto utiliza **apenas o npm** como gerenciador de pacotes.
- É proibido utilizar Yarn ou pnpm neste repositório.
- O único arquivo de lock permitido é o package-lock.json.
- Caso encontre arquivos yarn.lock ou pnpm-lock.yaml, remova-os imediatamente.

## 14. Duplicidade de Arquivos
- É proibido manter arquivos duplicados no projeto, incluindo:
  - Arquivos com nomes iguais em diretórios diferentes sem justificativa técnica clara.
  - Arquivos com sufixos como _old, -old, Copia, -copia, -copy, backup, etc.
  - Componentes, hooks ou utilitários que tenham a mesma responsabilidade em múltiplos lugares.
- Todo código duplicado deve ser centralizado e referenciado por import único.
- Pull Requests com duplicidade serão rejeitados.
- Justificativas para exceções devem ser documentadas no próprio código e aprovadas pelo time. 

# Regra Obrigatória de Atualização de Data no Cabeçalho

Sempre que qualquer alteração for realizada em um arquivo de código-fonte, a data da última atualização deve ser atualizada no cabeçalho do arquivo.

- O campo `Última atualização:` deve refletir a data da última modificação relevante no arquivo.
- O formato deve ser: `Última atualização: yyyy-mm-dd`
- Não é necessário alterar a data de criação (`Criado em:`), apenas a de atualização.
- Essa atualização é obrigatória para todos os arquivos `.ts`, `.tsx`, `.js`, `.jsx`, `.mjs`, `.css`, `.scss`, `.html` e `.md`.
- Pull Requests que não atualizarem a data de última atualização no cabeçalho dos arquivos modificados devem ser rejeitados.

**Exemplo de cabeçalho:**
```typescript
/**
 * Arquivo: MeuComponente.tsx
 * Caminho: src/components/MeuComponente.tsx
 * Criado em: 2025-06-01
 * Última atualização: 2025-06-10
 * Descrição: Componente React para exibir informações do usuário.
 */
``` 

# Regras de Organização de Arquivos e Diretórios

## 1. Estrutura de Diretórios
- Todo código-fonte deve estar dentro do diretório `src/`
- Documentação deve estar em `docs/`
- Arquivos estáticos (imagens, fontes, etc) devem estar em `public/`
- Scripts e utilitários devem estar em `src/scripts/`
- Configurações devem estar em `src/config/`

## 2. Proibição de Duplicidade
- É proibido manter arquivos duplicados no projeto
- Arquivos com sufixos como _old, -old, Copia, -copia, -copy, backup são proibidos
- Componentes, hooks ou utilitários com mesma responsabilidade devem ser centralizados
- Pull Requests com duplicidade serão rejeitados

## 3. Gerenciador de Pacotes
- Apenas npm é permitido
- É proibido usar Yarn ou pnpm
- O único arquivo de lock permitido é package-lock.json
- Remover imediatamente arquivos yarn.lock ou pnpm-lock.yaml

## 4. Arquivos de Configuração
- Manter apenas um arquivo de configuração por ferramenta
- Configurações do Jest devem estar em src/config/jest/
- Configurações do Next.js devem estar na raiz
- Configurações do TypeScript devem estar na raiz

## 5. Documentação
- Toda documentação deve estar em docs/
- Separar documentação técnica (docs/technical/) e de usuário (docs/user/)
- Manter README.md atualizado na raiz
- Documentar mudanças estruturais no CHANGELOG.md

## 6. Cabeçalho de Arquivos
- Todo arquivo de código-fonte deve ter cabeçalho padronizado
- Incluir nome do arquivo, caminho, data de criação e última atualização
- Atualizar data de última atualização em cada modificação
- PRs sem cabeçalho padronizado serão rejeitados

## 7. Imports
- Usar alias '@/' para imports dentro de src/
- Proibido usar caminhos relativos (../, ./) para arquivos em src/
- Manter imports organizados e agrupados
- Remover imports não utilizados

## 8. Tamanho de Arquivos
- Arquivos de código: 200-400 linhas
- Arquivos de teste: 100-200 linhas
- Arquivos de configuração: 50-100 linhas
- Dividir arquivos que excedam esses limites

## 9. Nomenclatura
- Páginas: minúsculo e hífen (kebab-case)
- Componentes: PascalCase
- Hooks: camelCase com prefixo 'use'
- Utilitários: camelCase
- Testes: .test.tsx ou .spec.tsx

## 10. Checklist de PR
- [ ] Arquivos seguem estrutura correta
- [ ] Sem duplicidade de código
- [ ] Cabeçalhos atualizados
- [ ] Imports usando alias '@/'
- [ ] Tamanho de arquivos adequado
- [ ] Nomenclatura correta
- [ ] Documentação atualizada
- [ ] Sem arquivos temporários
- [ ] Apenas npm como gerenciador de pacotes 

## Exceções à Regra de Organização

### Arquivos que DEVEM ficar na raiz:

1. **Configuração de Ferramentas**
   - `.cursorrules` (configuração do Cursor IDE)
   - `project_rules` (regras do projeto)
   - `.eslintrc.json` (configuração do ESLint)
   - `.gitignore` (configuração do Git)
   - `.npmrc` (configuração do npm)
   - `tsconfig.json` (configuração do TypeScript)
   - `next.config.mjs` (configuração do Next.js)

2. **Documentação Principal**
   - `README.md` (documentação principal do projeto)
   - `LICENSE` (licença do projeto)

3. **Arquivos de Build e Cache**
   - `tsconfig.tsbuildinfo` (cache do TypeScript)
   - `.next/` (build do Next.js)
   - `node_modules/` (dependências)

### Justificativa:
- Ferramentas como Cursor IDE, ESLint, TypeScript e Next.js esperam encontrar seus arquivos de configuração na raiz
- O README.md na raiz é um padrão do GitHub e outras plataformas
- Arquivos de build e cache precisam estar na raiz para funcionamento correto das ferramentas