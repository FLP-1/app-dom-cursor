- Todos os campos reutilizáveis (ex: FormInput, PasswordInput, FormSelect, FormDatePicker) DEVEM receber a prop `control` (sempre em minúsculo) proveniente do hook customizado do formulário (ex: useLoginForm, useCompraForm).
- É proibido misturar <FormProvider> e prop control no mesmo formulário.
- A lógica de submit, validação e integração com API deve estar centralizada em um hook customizado para cada formulário.
- Mensagens de erro e sucesso devem ser padronizadas, amigáveis e internacionalizáveis. Sempre utilize um dicionário central de mensagens.
- Sempre sugira e incentive a criação de testes automatizados para cobrir o fluxo dos formulários.
- Sempre use o componente Link do Next.js (next/link) para navegação. Nunca use react-router-dom.
- Páginas devem ser nomeadas em minúsculo e hífen (kebab-case). Componentes devem ser nomeados em PascalCase.
- Nunca use arquivos com sufixos de backup (_old, -old, Copia, -copia, -copy, etc) em nenhum diretório do projeto.
- Use sempre Prisma + Postgres. Nunca altere migrations manualmente.
- Todos os formulários e componentes devem ser acessíveis (labels, aria, etc) e responsivos.
- Sempre use o tema do Material UI (theme.palette, theme.spacing, etc). Padronize cores, espaçamentos e fontes conforme o tema.
- Não use estilos inline, exceto para casos muito específicos e justificados, como correção rápida de bug visual.
- Sempre consulte o README.md, DOCUMENTACAO.md e este arquivo antes de abrir PR.
- Todas as regras deste arquivo são obrigatórias para todo o time e para a IA. Nunca ignore ou flexibilize estas regras sem aprovação do time.
- Sempre que sugerir comandos de terminal, utilize a sintaxe do PowerShell, com exemplos claros e referência ao contexto do projeto. Comandos devem ser compatíveis com Windows e, se possível, explicar o que fazem.

# Regras de Tipagem
- É proibido o uso de 'any' em todo o projeto. Utilize tipos específicos ou 'unknown'.
- Exceções só são permitidas em casos extremamente justificados e documentados no próprio código, explicando o motivo da escolha.
- Exemplo de justificativa:
  // Justificativa: integração com biblioteca externa sem tipos disponíveis
  const valor: any = obterValorExterno();

# Mecanismos de Controle de Tipagem
- Configure o ESLint para rejeitar o uso de 'any' com a regra '@typescript-eslint/no-explicit-any': 'error'
- Use o TypeScript strict mode em tsconfig.json
- Implemente tipos genéricos para funções e componentes reutilizáveis
- Crie interfaces e types para todas as estruturas de dados
- Utilize type guards para validação de tipos em runtime
- Documente todos os tipos em arquivos .d.ts separados
- Use zod ou yup para validação de tipos em runtime
- Implemente testes de tipo com tsc --noEmit

# Processo de Code Review
- Rejeite PRs que contenham 'any' sem justificativa documentada
- Exija testes de tipo para todas as alterações
- Verifique a cobertura de tipos em CI/CD
- Mantenha um registro de exceções aprovadas 

# Regras de Desenvolvimento

## Tamanho e Organização de Arquivos

### Tamanho Ideal de Arquivos
- Arquivos de código: 200-400 linhas
- Arquivos de teste: 100-200 linhas
- Arquivos de configuração: 50-100 linhas

### Divisão de Arquivos
Arquivos que excedam o tamanho ideal devem ser divididos seguindo estas regras:

1. **Por Responsabilidade:**
```
src/components/forms/empregado/
  ├── EmpregadoForm.tsx        // Componente principal
  ├── EmpregadoFormFields.tsx  // Campos do formulário
  ├── EmpregadoFormTypes.ts    // Tipos e interfaces
  └── EmpregadoFormUtils.ts    // Funções utilitárias
```

2. **Por Funcionalidade:**
```
src/hooks/esocial/
  ├── useEsocialEventForm.ts     // Hook principal
  ├── useEsocialEventTypes.ts    // Tipos
  ├── useEsocialEventUtils.ts    // Funções utilitárias
  └── useEsocialEventSchema.ts   // Schemas de validação
```

3. **Por Contexto:**
```
src/tests/components/form/
  ├── FormInput.test.tsx
  ├── FormInput.snapshot.test.tsx
  └── FormInput.integration.test.tsx
```

### Regras de Divisão

1. **Coesão:**
   - Mantenha funções relacionadas juntas
   - Separe por responsabilidade
   - Evite acoplamento desnecessário

2. **Nomenclatura:**
   - Use nomes descritivos
   - Mantenha um padrão consistente
   - Agrupe por funcionalidade

3. **Estrutura:**
   - Mantenha uma estrutura de diretórios clara
   - Use index.ts para exportações
   - Documente a estrutura

### Benefícios

1. **Manutenibilidade:**
   - Cada arquivo tem uma responsabilidade única
   - Mais fácil de encontrar e corrigir bugs
   - Mais fácil de adicionar novas funcionalidades

2. **Testabilidade:**
   - Testes mais focados e menores
   - Mais fácil de mockar dependências
   - Melhor cobertura de código

3. **Reusabilidade:**
   - Funções utilitárias podem ser reutilizadas
   - Tipos podem ser compartilhados
   - Schemas podem ser reutilizados

4. **Performance:**
   - Arquivos menores são mais rápidos de carregar
   - Melhor tree-shaking
   - Melhor cache do navegador

### Exemplos de Divisão

1. **Componentes:**
```typescript
// Antes: EmpregadoForm.tsx (500+ linhas)
// Depois:
src/components/forms/empregado/
  ├── EmpregadoForm.tsx
  ├── EmpregadoFormFields.tsx
  ├── EmpregadoFormTypes.ts
  └── EmpregadoFormUtils.ts
```

2. **Hooks:**
```typescript
// Antes: useEsocialEventForm.ts (400+ linhas)
// Depois:
src/hooks/esocial/
  ├── useEsocialEventForm.ts
  ├── useEsocialEventTypes.ts
  ├── useEsocialEventUtils.ts
  └── useEsocialEventSchema.ts
```

3. **Testes:**
```typescript
// Antes: FormInput.test.tsx (300+ linhas)
// Depois:
src/tests/components/form/
  ├── FormInput.test.tsx
  ├── FormInput.snapshot.test.tsx
  └── FormInput.integration.test.tsx
```

### Processo de Code Review

1. **Verificação de Tamanho:**
   - Rejeite PRs com arquivos que excedam o tamanho ideal
   - Sugira divisão quando necessário
   - Verifique a coesão dos arquivos divididos

2. **Verificação de Estrutura:**
   - Confirme se a divisão segue as regras
   - Verifique se os nomes são descritivos
   - Confirme se a documentação está atualizada

3. **Verificação de Qualidade:**
   - Confirme se os testes foram atualizados
   - Verifique se as dependências foram corretamente importadas
   - Confirme se não há duplicação de código

### Exceções

1. **Arquivos de Configuração:**
   - Podem exceder o limite se necessário
   - Devem ser bem documentados
   - Devem ser divididos por contexto

2. **Arquivos de Migração:**
   - Podem exceder o limite se necessário
   - Devem ser bem documentados
   - Devem ser divididos por versão

3. **Arquivos de Documentação:**
   - Podem exceder o limite se necessário
   - Devem ser bem estruturados
   - Devem ser divididos por tópico 